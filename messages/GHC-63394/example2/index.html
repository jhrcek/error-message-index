<h2 id="error-message">Error Message</h2>
<pre><code>PartialTail.hs:6:3: warning: [GHC-63394] [-Wx-partial]
    In the use of ‘tail’
    (imported from Prelude, but defined in GHC.List):
    &quot;This is a partial function, it throws an error on empty lists. Replace it with drop 1, or use pattern matching or Data.List.uncons instead. Consider refactoring to use Data.List.NonEmpty.&quot;
  |
6 |   tail list
  |   ^^^^</code></pre>

<pre class="filename">PartialTail.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">module PartialTail where

example :: [Int]
example =
  let list = 1 : 2 : 3 : [] in
  tail list
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">module PartialTail where

import Data.List.NonEmpty (NonEmpty((:|)))
import qualified Data.List.NonEmpty as NonEmpty

-- Replace `tail` with `drop 1`.
example1 :: [Int]
example1 =
  let list = 1 : 2 : 3 : [] in
  drop 1 list

-- Use pattern-matching.
example2 :: [Int]
example2  =
  let list = 1 : 2 : 3 : [] in
  case list of
    [] -> []
    _ : xs -> xs

-- Refactor to use NonEmpty.tail.
example3 :: [Int]
example3 =
  let list :: NonEmpty Int
      list = 1 :| 2 : 3 : [] in
  NonEmpty.tail list
</code></pre>
    </div>
  </div>
</div>

